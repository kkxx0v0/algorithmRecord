//许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。
// 然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。
//决定球运动方向的是每个节点的布尔值。
// 最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。
// 如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。
//因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。
// 第二个球将会访问节点 1、3、6，在节点 12 停止。明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。
//现在你的任务是，给定新满二叉树的深度 d 和下落的小球的编号 i ，可以假定I不超过给定的新满二叉树的叶子数，写一个程序求小球停止时的叶子序号p。
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string>
const int maxd = 20;
int s[1 << maxd];//最大结点数为2的maxd次方减一
int main()
{
	int D, I;
	while (scanf("%d%d", &D, &I) == 2)
	{
		memset(s, 0, sizeof(s));//开关
		int k, n = (1 << D) - 1;//n是最大结点编号
		for (int i = 0; i < I; i++)//I个球下落
		{
			k = 1;
			for (;;)//是否出界
			{
				s[k] = !s[k];
				k = s[k] ? k * 2 : k * 2 + 1;//由开关选择下落方向
				if (k > n)
					break;
			}
		}
		printf("%d\n", k / 2);//出界前叶子编号
	}
	return 0;
}